<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>CVEN 6833 - Homework 3</title>
  <meta name="description" content="Code and output for Homework Set 3">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="CVEN 6833 - Homework 3" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Code and output for Homework Set 3" />
  <meta name="github-repo" content="albegon1/CVEN6833-HW3" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="CVEN 6833 - Homework 3" />
  
  <meta name="twitter:description" content="Code and output for Homework Set 3" />
  

<meta name="author" content="Alex Belenguer">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="multivariate-simulation-copulas.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">CVEN 6833 - HW#3</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Topics</a></li>
<li class="chapter" data-level="1" data-path="seasonal-ar1-model.html"><a href="seasonal-ar1-model.html"><i class="fa fa-check"></i><b>1</b> Seasonal AR(1) model</a><ul>
<li class="chapter" data-level="1.1" data-path="seasonal-ar1-model.html"><a href="seasonal-ar1-model.html#generate-250-simulations-each-of-same-length-as-the-historical-data."><i class="fa fa-check"></i><b>1.1</b> Generate 250 simulations each of same length as the historical data.</a></li>
<li class="chapter" data-level="1.2" data-path="seasonal-ar1-model.html"><a href="seasonal-ar1-model.html#plot-statistics-from-simulations"><i class="fa fa-check"></i><b>1.2</b> Plot statistics from simulations</a></li>
<li class="chapter" data-level="1.3" data-path="seasonal-ar1-model.html"><a href="seasonal-ar1-model.html#replace-the-simulation-of-the-errors-or-innovations-from-normal-to-gamma"><i class="fa fa-check"></i><b>1.3</b> Replace the simulation of the errors (or innovations) from Normal to Gamma</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="nonparametric-seasonal-lag-1-model.html"><a href="nonparametric-seasonal-lag-1-model.html"><i class="fa fa-check"></i><b>2</b> Nonparametric seasonal lag-1 model</a><ul>
<li class="chapter" data-level="2.1" data-path="nonparametric-seasonal-lag-1-model.html"><a href="nonparametric-seasonal-lag-1-model.html#generate-250-simulations-each-of-same-length-as-the-historical-data.-1"><i class="fa fa-check"></i><b>2.1</b> Generate 250 simulations each of same length as the historical data.</a></li>
<li class="chapter" data-level="2.2" data-path="nonparametric-seasonal-lag-1-model.html"><a href="nonparametric-seasonal-lag-1-model.html#plot-statistics-from-simulations-1"><i class="fa fa-check"></i><b>2.2</b> Plot statistics from simulations</a></li>
<li class="chapter" data-level="2.3" data-path="nonparametric-seasonal-lag-1-model.html"><a href="nonparametric-seasonal-lag-1-model.html#advantagesdisadvantages-with-a-nonparametric-approach."><i class="fa fa-check"></i><b>2.3</b> Advantages/disadvantages with a nonparametric approach.</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="multivariate-simulation-copulas.html"><a href="multivariate-simulation-copulas.html"><i class="fa fa-check"></i><b>3</b> Multivariate Simulation - Copulas</a><ul>
<li class="chapter" data-level="3.0.1" data-path="multivariate-simulation-copulas.html"><a href="multivariate-simulation-copulas.html#data-import-and-setup"><i class="fa fa-check"></i><b>3.0.1</b> Data import and setup</a></li>
<li class="chapter" data-level="3.1" data-path="multivariate-simulation-copulas.html"><a href="multivariate-simulation-copulas.html#fit-a-copula-to-the-joint-cdf-copula-by-pairs"><i class="fa fa-check"></i><b>3.1</b> Fit a Copula to the joint CDF (copula by pairs)</a></li>
<li class="chapter" data-level="3.2" data-path="multivariate-simulation-copulas.html"><a href="multivariate-simulation-copulas.html#simulate-from-the-copula-and-invert"><i class="fa fa-check"></i><b>3.2</b> Simulate from the Copula and invert</a></li>
<li class="chapter" data-level="3.3" data-path="multivariate-simulation-copulas.html"><a href="multivariate-simulation-copulas.html#boxplot-the-statistics-listed-in-problem-1-and-compare-with-the-results-from-the-previous-methods"><i class="fa fa-check"></i><b>3.3</b> Boxplot the statistics listed in problem 1 and compare with the results from the previous methods</a></li>
<li class="chapter" data-level="3.4" data-path="multivariate-simulation-copulas.html"><a href="multivariate-simulation-copulas.html#months-copula"><i class="fa fa-check"></i><b>3.4</b> 12 months copula</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="non-stationary-time-series-hidden-markov-model.html"><a href="non-stationary-time-series-hidden-markov-model.html"><i class="fa fa-check"></i><b>4</b> Non stationary time series - Hidden Markov Model</a><ul>
<li class="chapter" data-level="4.1" data-path="non-stationary-time-series-hidden-markov-model.html"><a href="non-stationary-time-series-hidden-markov-model.html#fit-a-best-hmm-for-the-may-lees-ferry-streamflow"><i class="fa fa-check"></i><b>4.1</b> Fit a best HMM for the May Lees Ferry streamflow</a></li>
<li class="chapter" data-level="4.2" data-path="non-stationary-time-series-hidden-markov-model.html"><a href="non-stationary-time-series-hidden-markov-model.html#generate-250-simulations-from-the-fitted-hmm"><i class="fa fa-check"></i><b>4.2</b> Generate 250 simulations from the fitted HMM</a></li>
<li class="chapter" data-level="4.3" data-path="non-stationary-time-series-hidden-markov-model.html"><a href="non-stationary-time-series-hidden-markov-model.html#boxplot-the-resulting-statistics"><i class="fa fa-check"></i><b>4.3</b> Boxplot the resulting statistics</a></li>
<li class="chapter" data-level="4.4" data-path="non-stationary-time-series-hidden-markov-model.html"><a href="non-stationary-time-series-hidden-markov-model.html#fit-a-glm-for-the-state-series"><i class="fa fa-check"></i><b>4.4</b> Fit a GLM for the state series</a></li>
<li class="chapter" data-level="4.5" data-path="non-stationary-time-series-hidden-markov-model.html"><a href="non-stationary-time-series-hidden-markov-model.html#use-the-state-glm-to-simulate-flows-from-the-component-distribution"><i class="fa fa-check"></i><b>4.5</b> Use the state GLM to simulate flows from the component distribution</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li> 

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">CVEN 6833 - Homework 3</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="non-stationary-time-series---hidden-markov-model" class="section level1">
<h1><span class="header-section-number">Exercise 4</span> Non stationary time series - Hidden Markov Model</h1>
<p>Another way to simulate a time series is using Hidden Markov Model (Markov Chain + resampling).</p>
<p>First, we load the libraries, streamflow data, and functions via R markdown (attached at the end of the document).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># libraries</span>
libr=<span class="kw">c</span>(<span class="st">&quot;HiddenMarkov&quot;</span>,<span class="st">&quot;ggplot2&quot;</span>,<span class="st">&quot;data.table&quot;</span>,<span class="st">&quot;ggthemes&quot;</span>,
       <span class="st">&quot;magrittr&quot;</span>,<span class="st">&quot;sm&quot;</span>,<span class="st">&quot;moments&quot;</span>,<span class="st">&quot;MASS&quot;</span>,<span class="st">&quot;leaps&quot;</span>)
<span class="kw">options</span>(<span class="dt">warn=</span><span class="dv">1</span>)
<span class="kw">suppressPackageStartupMessages</span>(<span class="kw">lapply</span>(libr, 
                require, <span class="dt">character.only =</span> <span class="ot">TRUE</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Load flow data

flow =<span class="st"> </span><span class="kw">read.table</span>(
  <span class="st">&quot;http://civil.colorado.edu/~balajir/CVEN6833/HWs/HW-3-2018/LeesFerry-monflows-1906-2016.txt&quot;</span>)

flow =<span class="st"> </span>flow[,<span class="dv">2</span><span class="op">:</span><span class="dv">13</span>] <span class="op">%&gt;%</span><span class="st"> `</span><span class="dt">rownames&lt;-</span><span class="st">`</span>(flow[,<span class="dv">1</span>]) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">setNames</span>(.,<span class="kw">c</span>(<span class="st">&quot;jan&quot;</span>,<span class="st">&quot;feb&quot;</span>,<span class="st">&quot;mar&quot;</span>,<span class="st">&quot;apr&quot;</span>,<span class="st">&quot;may&quot;</span>,<span class="st">&quot;jun&quot;</span>,
                      <span class="st">&quot;jul&quot;</span>,<span class="st">&quot;aug&quot;</span>,<span class="st">&quot;sep&quot;</span>,<span class="st">&quot;oct&quot;</span>,<span class="st">&quot;nov&quot;</span>,<span class="st">&quot;dec&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">                      </span>{.<span class="op">/</span><span class="dv">10</span><span class="op">^</span><span class="dv">6</span>} <span class="co"># convert AF to MAF</span>

x =<span class="st"> </span>flow<span class="op">$</span>may    ## select the May month flows</code></pre></div>
<div id="fit-a-best-hmm-for-the-may-lees-ferry-streamflow" class="section level2">
<h2><span class="header-section-number">4.1</span> Fit a best HMM for the May Lees Ferry streamflow</h2>
<p>The code below fits HMM models of orders 2 through 6 and calculates the AIC for each. The best order is the one with the least value of AIC.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Fit HMM models of orders 2 through 6. Obtain the AIC  for each
## Best order is the one with the least value of AIC.
family &lt;-<span class="st"> &quot;gamma&quot;</span>  <span class="co"># underlying distribution for hmm</span>
discrete &lt;-<span class="st"> </span><span class="ot">FALSE</span>
aic1=<span class="kw">c</span>()

<span class="cf">for</span>(imodel <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="dv">6</span>){
  m &lt;-<span class="st"> </span>imodel      <span class="co">#model order to fit</span>
  stationary &lt;-<span class="st"> </span>F   <span class="co"># use a stationary distribution of mixtures</span>
      <span class="co"># different initial condition types when family == &quot;norm&quot;</span>
  ic &lt;-<span class="st"> &quot;same.sd&quot;</span><span class="co">#c(&quot;same.sd&quot;,&quot;same.both&quot;,&quot;both.diff&quot;)</span>
  fd.name &lt;-<span class="st"> </span><span class="kw">ifelse</span>(family <span class="op">==</span><span class="st"> &quot;norm&quot;</span>, <span class="st">&quot;normal&quot;</span>, family)
  Pi &lt;-<span class="st"> </span><span class="kw">Pi_init</span>(m)     <span class="co"># T.P.M.</span>
  delta &lt;-<span class="st"> </span><span class="kw">delta_init</span>(m)
  pars &lt;-<span class="st"> </span><span class="kw">get.named.parlist</span>(x, m, fd.name, <span class="dt">lower=</span>.<span class="dv">0</span>, ic)<span class="co">#,start=list(shape1=2,shape2=2))</span>
  <span class="co"># set up the model</span>
  hmm &lt;-<span class="st"> </span><span class="kw">dthmm</span>(x, <span class="dt">Pi=</span>Pi, <span class="dt">delta=</span>delta, family, pars, <span class="dt">nonstat=</span><span class="op">!</span>stationary, <span class="dt">discrete =</span> discrete)
  <span class="kw">sink</span>(<span class="st">&quot;p.4.hmm.fit&quot;</span>)
  <span class="cf">if</span>(imodel <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span>){
   hmm &lt;-<span class="st"> </span><span class="kw">BaumWelch</span>(hmm, <span class="kw">bwcontrol</span>(<span class="dt">maxiter =</span> <span class="dv">1000</span>,
          <span class="dt">posdiff=</span><span class="ot">TRUE</span>,<span class="dt">converge =</span> <span class="kw">expression</span>(diff <span class="op">&gt;</span><span class="st"> </span>tol)))
   } <span class="cf">else</span> {
   hmm &lt;-<span class="st"> </span><span class="kw">BaumWelch</span>(hmm, <span class="kw">bwcontrol</span>(<span class="dt">maxiter =</span> <span class="dv">1000</span>, <span class="dt">tol =</span> <span class="fl">1e-08</span>))
   }
  <span class="kw">sink</span>()
  <span class="co"># get the hidden states from the fitted model </span>
  <span class="co"># Global decoding. To get the probability of being in a state: hmm$u</span>
  decoding &lt;-<span class="st"> </span><span class="kw">Viterbi</span>(hmm)
  <span class="co"># get AIC</span>
  aic &lt;-<span class="st"> </span><span class="kw">AIC</span>(hmm)
  aic1=<span class="kw">c</span>(aic1,aic)
}</code></pre></div>
<p>We select the HMM with the lowest AIC. In this case, this happens to be of order 2.</p>
<p>We rerun the HMM for best order (m=2) and generate the state sequence (decoding) resulting from it. The model summary is also attached.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Get the best order
bestorder =<span class="st"> </span><span class="kw">order</span>(aic1)[<span class="dv">1</span>] <span class="op">+</span><span class="dv">1</span>
## Fit the model for this best order
m &lt;-<span class="st"> </span>bestorder      <span class="co">#model order to fit</span>
stationary &lt;-<span class="st"> </span>F   <span class="co"># use a stationary distribution of mixtures</span>
    <span class="co"># different initial condition types when family == &quot;norm&quot;</span>
ic &lt;-<span class="st"> &quot;same.sd&quot;</span><span class="co">#c(&quot;same.sd&quot;,&quot;same.both&quot;,&quot;both.diff&quot;)</span>
fd.name &lt;-<span class="st"> </span><span class="kw">ifelse</span>(family <span class="op">==</span><span class="st"> &quot;norm&quot;</span>, <span class="st">&quot;normal&quot;</span>, family)
Pi &lt;-<span class="st"> </span><span class="kw">Pi_init</span>(m)   <span class="co"># T.P.M.</span>
delta &lt;-<span class="st"> </span><span class="kw">delta_init</span>(m)
pars &lt;-<span class="st"> </span><span class="kw">get.named.parlist</span>(x, m, fd.name, <span class="dt">lower=</span>.<span class="dv">0</span>, ic)<span class="co">#,start=list(shape1=2,shape2=2))</span>
  <span class="co"># set up the model</span>
hmm &lt;-<span class="st"> </span><span class="kw">dthmm</span>(x, <span class="dt">Pi=</span>Pi, <span class="dt">delta=</span>delta, family, pars, <span class="dt">nonstat=</span><span class="op">!</span>stationary, <span class="dt">discrete =</span> discrete)
<span class="kw">sink</span>(<span class="st">&quot;p.4.best.hmm&quot;</span>)
hmm &lt;-<span class="st"> </span><span class="kw">BaumWelch</span>(hmm, <span class="kw">bwcontrol</span>(<span class="dt">maxiter =</span> <span class="dv">1000</span>, <span class="dt">tol =</span> <span class="fl">1e-08</span>)) 
<span class="kw">sink</span>() <span class="co"># end hidding output</span>
decoding &lt;-<span class="st"> </span><span class="kw">Viterbi</span>(hmm)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">summary</span>(hmm))</code></pre></div>
<pre><code>## $delta
## [1]  1.000000e+00 1.165686e-105
## 
## $Pi
##           [,1]      [,2]
## [1,] 0.7046161 0.2953839
## [2,] 0.3414245 0.6585755
## 
## $nonstat
## [1] TRUE
## 
## $distn
## [1] &quot;gamma&quot;
## 
## $pm
## $pm$rate
## [1] 4.062194 2.974821
## 
## $pm$shape
## [1] 15.20308  6.99202
## 
## 
## $discrete
## [1] FALSE
## 
## $n
## [1] 111</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="st">&#39;Model order:&#39;</span>,m,<span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)</code></pre></div>
<pre><code>## Model order: 2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p &lt;-<span class="st"> </span><span class="kw">ggplot_stationary_hmm</span>(hmm,.<span class="dv">5</span>)
<span class="kw">print</span>(p)</code></pre></div>
<pre><code>## Warning: Removed 1 rows containing missing values (geom_bar).</code></pre>
<p><img src="CVEN_6833_-_HW3_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">state.<span class="dv">1</span>=<span class="kw">ifelse</span>(decoding<span class="op">==</span><span class="dv">1</span>,<span class="fl">2.5</span>,<span class="ot">NA</span>)
state.<span class="dv">2</span>=<span class="kw">ifelse</span>(decoding<span class="op">==</span><span class="dv">2</span>,<span class="fl">0.5</span>,<span class="ot">NA</span>)
<span class="kw">plot</span>(flow<span class="op">$</span>may<span class="op">-</span><span class="kw">mean</span>(flow<span class="op">$</span>may)<span class="op">+</span><span class="fl">1.5</span>,<span class="dt">type=</span><span class="st">&quot;l&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;&quot;</span>,
     <span class="dt">main=</span><span class="st">&quot;Modified May flows and states (supperposed)&quot;</span>)
<span class="kw">points</span>(state.<span class="dv">2</span>,<span class="dt">col=</span><span class="st">&#39;blue&#39;</span>)
<span class="kw">points</span>(state.<span class="dv">1</span>,<span class="dt">col=</span><span class="st">&#39;red&#39;</span>)
<span class="kw">legend</span>(<span class="st">&quot;topright&quot;</span>,<span class="dt">legend=</span><span class="kw">c</span>(<span class="st">&quot;state 1&quot;</span>,<span class="st">&quot;state 2&quot;</span>),<span class="dt">col=</span><span class="kw">c</span>(<span class="st">&quot;red&quot;</span>,<span class="st">&quot;blue&quot;</span>),<span class="dt">pch=</span><span class="dv">1</span>)</code></pre></div>
<p><img src="CVEN_6833_-_HW3_files/figure-html/unnamed-chunk-3-2.png" width="672" /></p>
</div>
<div id="generate-250-simulations-from-the-fitted-hmm" class="section level2">
<h2><span class="header-section-number">4.2</span> Generate 250 simulations from the fitted HMM</h2>
<p>This involves generating the state sequence from the transition probability matrix and resampling flows from the corresponding component distribution.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Now simulate</span>
<span class="co"># First simulate a sequence of states from the TPM</span>
<span class="co"># simulate from the transition probability</span>
N =<span class="st"> </span><span class="kw">length</span>(x)
nsim =<span class="st"> </span><span class="dv">250</span>
nprob =<span class="st"> </span><span class="kw">length</span>(decoding[decoding <span class="op">==</span><span class="st"> </span><span class="dv">1</span>])<span class="op">/</span>N
delta1=<span class="kw">c</span>(nprob,<span class="dv">1</span><span class="op">-</span>nprob)   <span class="co">#stationary probability</span>
zsim =<span class="st"> </span><span class="kw">mchain</span>(<span class="ot">NULL</span>,hmm<span class="op">$</span>Pi,<span class="dt">delta=</span>delta1)
may.sim =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow=</span>nsim,<span class="dt">ncol=</span>N)

<span class="co"># Points where May PDF is evaluated </span>
xeval=<span class="kw">seq</span>(<span class="kw">min</span>(flow<span class="op">$</span>may)<span class="op">-</span><span class="fl">0.25</span><span class="op">*</span><span class="kw">sd</span>(flow<span class="op">$</span>may),
          <span class="kw">max</span>(flow<span class="op">$</span>may)<span class="op">+</span><span class="fl">0.25</span><span class="op">*</span><span class="kw">sd</span>(flow<span class="op">$</span>may),<span class="dt">length=</span><span class="dv">100</span>)
sim.pdf=<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow=</span>nsim,<span class="dt">ncol=</span><span class="dv">100</span>) <span class="co"># Array to store May simulated PDF</span>

may.stat=<span class="kw">matrix</span>(<span class="ot">NA</span>,<span class="dt">ncol =</span> <span class="dv">6</span>,<span class="dt">nrow =</span> nsim) <span class="co"># year statistics</span>
<span class="kw">colnames</span>(may.stat) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;mean&quot;</span>,<span class="st">&quot;stdev&quot;</span>,<span class="st">&quot;min&quot;</span>,<span class="st">&quot;max&quot;</span>,<span class="st">&quot;skew&quot;</span>,<span class="st">&quot;cor&quot;</span>)

<span class="cf">for</span>(isim <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nsim){
  zsim =<span class="st"> </span><span class="kw">simulate</span>(zsim,<span class="dt">nsim=</span>N)
  ## now simulate the flows from the corresponding PDF
  flowsim =<span class="st"> </span><span class="kw">c</span>()
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N){
    <span class="cf">if</span>(zsim<span class="op">$</span>mc[i] <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)xx=<span class="kw">rgamma</span>(<span class="dv">1</span>,<span class="dt">shape=</span>hmm<span class="op">$</span>pm<span class="op">$</span>shape[<span class="dv">1</span>],
                                 <span class="dt">scale=</span><span class="dv">1</span><span class="op">/</span>hmm<span class="op">$</span>pm<span class="op">$</span>rate[<span class="dv">1</span>])
    <span class="cf">if</span>(zsim<span class="op">$</span>mc[i] <span class="op">==</span><span class="st"> </span><span class="dv">2</span>)xx=<span class="kw">rgamma</span>(<span class="dv">1</span>,<span class="dt">shape=</span>hmm<span class="op">$</span>pm<span class="op">$</span>shape[<span class="dv">2</span>],
                                 <span class="dt">scale=</span><span class="dv">1</span><span class="op">/</span>hmm<span class="op">$</span>pm<span class="op">$</span>rate[<span class="dv">2</span>])
    flowsim=<span class="kw">c</span>(flowsim,xx)
  }
  may.sim[isim,]=flowsim
  sim.pdf[isim,]=<span class="kw">sm.density</span>(flowsim,<span class="dt">eval.points=</span>xeval,
                            <span class="dt">display=</span><span class="st">&quot;none&quot;</span>)<span class="op">$</span>estimate
  <span class="co"># fill statistics</span>
  may.stat[isim,<span class="st">&quot;mean&quot;</span>]=<span class="kw">mean</span>(flowsim)
  may.stat[isim,<span class="st">&quot;max&quot;</span>]=<span class="kw">max</span>(flowsim)
  may.stat[isim,<span class="st">&quot;min&quot;</span>]=<span class="kw">min</span>(flowsim)
  may.stat[isim,<span class="st">&quot;stdev&quot;</span>]=<span class="kw">sd</span>(flowsim)
  may.stat[isim,<span class="st">&quot;skew&quot;</span>]=<span class="kw">skewness</span>(flowsim)
  may.stat[isim,<span class="st">&quot;cor&quot;</span>]=<span class="kw">cor</span>(flowsim[<span class="op">-</span>N],flowsim[<span class="dv">2</span><span class="op">:</span>N])
}</code></pre></div>
<p>The statistics from the historical data is added in the first row of the statistics matrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Compute statistics from the historical data.</span>
obs=<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>
obs[<span class="dv">1</span>]=<span class="kw">mean</span>(flow<span class="op">$</span>may)
obs[<span class="dv">2</span>]=<span class="kw">sd</span>(flow<span class="op">$</span>may)
obs[<span class="dv">3</span>]=<span class="kw">min</span>(flow<span class="op">$</span>may)
obs[<span class="dv">4</span>]=<span class="kw">max</span>(flow<span class="op">$</span>may)
obs[<span class="dv">5</span>]=<span class="kw">skewness</span>(flow<span class="op">$</span>may)
obs[<span class="dv">6</span>]=<span class="kw">cor</span>(flow<span class="op">$</span>may[<span class="op">-</span>N],flow<span class="op">$</span>may[<span class="dv">2</span><span class="op">:</span>N])
<span class="co"># bind the stats of the historic data at the top..</span>
may.stat=<span class="kw">rbind</span>(obs,may.stat)</code></pre></div>
</div>
<div id="boxplot-the-resulting-statistics" class="section level2">
<h2><span class="header-section-number">4.3</span> Boxplot the resulting statistics</h2>
<p>We include the mean, variance, skew, lag-1 correlation, minimum, maximum and PDF from the simulations with the corresponding values from the historical data plotted on them.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># function to plot boxplots with the structure: hist. in first row</span>
plot.bp =<span class="st"> </span><span class="cf">function</span>(matrix,name){
  xmeans=<span class="kw">as.matrix</span>(matrix)
  n=<span class="kw">length</span>(xmeans[,<span class="dv">1</span>])
  xmeans1=<span class="kw">as.matrix</span>(xmeans[<span class="dv">2</span><span class="op">:</span>n,]) <span class="co">#the first row is the original data</span>
  xs=<span class="dv">1</span><span class="op">:</span><span class="dv">12</span>
  zz=<span class="kw">boxplot</span>(<span class="kw">split</span>(xmeans1,<span class="kw">col</span>(xmeans1)), <span class="dt">plot=</span>F, <span class="dt">cex=</span><span class="fl">1.0</span>)
  zz<span class="op">$</span>names=<span class="kw">rep</span>(<span class="st">&quot;&quot;</span>,<span class="kw">length</span>(zz<span class="op">$</span>names))
  z1=<span class="kw">bxp</span>(zz,<span class="dt">ylim=</span><span class="kw">range</span>(xmeans),<span class="dt">xlab=</span><span class="st">&quot;&quot;</span>,<span class="dt">ylab=</span><span class="st">&quot;&quot;</span>,<span class="dt">cex=</span><span class="fl">1.00</span>)
  <span class="kw">points</span>(z1,xmeans[<span class="dv">1</span>,],<span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
  <span class="kw">lines</span>(z1,xmeans[<span class="dv">1</span>,],<span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">&quot;gray&quot;</span>)
  <span class="kw">title</span>(<span class="dt">main=</span>name)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>))
<span class="kw">plot.bp</span>(may.stat[,<span class="st">&quot;mean&quot;</span>],<span class="st">&quot;Mean&quot;</span>)
<span class="kw">plot.bp</span>(may.stat[,<span class="st">&quot;stdev&quot;</span>],<span class="st">&quot;Standard Deviation&quot;</span>)
<span class="kw">plot.bp</span>(may.stat[,<span class="st">&quot;min&quot;</span>],<span class="st">&quot;Min&quot;</span>)
<span class="kw">plot.bp</span>(may.stat[,<span class="st">&quot;max&quot;</span>],<span class="st">&quot;Max&quot;</span>)
<span class="kw">plot.bp</span>(may.stat[,<span class="st">&quot;skew&quot;</span>],<span class="st">&quot;Skews&quot;</span>)
<span class="kw">plot.bp</span>(may.stat[,<span class="st">&quot;cor&quot;</span>],<span class="st">&quot;Lag-1 correlation&quot;</span>)</code></pre></div>
<p><img src="CVEN_6833_-_HW3_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xdensityorig =<span class="st"> </span>flow<span class="op">$</span>may <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">sm.density</span>(.,<span class="dt">eval.points=</span>xeval,<span class="dt">display=</span><span class="st">&quot;none&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span>.<span class="op">$</span>estimate

plot.pdf =<span class="st"> </span><span class="cf">function</span>(eval,histPDF,simPDF){
  xeval =<span class="st"> </span>eval
  <span class="kw">plot</span>(xeval,histPDF,<span class="dt">pch=</span><span class="st">&quot;.&quot;</span>,<span class="dt">col=</span><span class="st">&quot;red&quot;</span>,<span class="dt">ylim=</span><span class="kw">range</span>(simPDF,histPDF),
       <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>,<span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>)
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nsim)<span class="kw">lines</span>(xeval,simPDF[i,],<span class="dt">col=</span><span class="st">&#39;lightgrey&#39;</span>,<span class="dt">lty=</span><span class="dv">3</span>)
  <span class="kw">lines</span>(xeval,histPDF,<span class="dt">lwd=</span><span class="dv">3</span>,<span class="dt">col=</span><span class="st">&quot;red&quot;</span>)
  <span class="kw">title</span>(<span class="dt">main=</span><span class="st">&quot;Historical vs. simulated PDF&quot;</span>)
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot.pdf</span>(xeval,xdensityorig,sim.pdf)</code></pre></div>
<p><img src="CVEN_6833_-_HW3_files/figure-html/plot.pdf.month-1.png" width="672" /></p>
<p>The model is able to represent accurately all statistics, including lag-1 correlation.</p>
</div>
<div id="fit-a-glm-for-the-state-series" class="section level2">
<h2><span class="header-section-number">4.4</span> Fit a GLM for the state series</h2>
<p>Instead of simulating the streamflow from a “static” state sequence simulation, the goal is to simulate the state as a prediction from a best logistic GLM. The uncertainty is added choosing random values and comparing them to the initial probability (p1 / p2) of being in a particular state.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">enso=<span class="kw">read.table</span>(<span class="st">&quot;C:/Users/alexb/Google Drive/CVEN 6833 ADAT/zz Homeworks/HW3/enso.txt&quot;</span>)
amo=<span class="kw">read.table</span>(<span class="st">&quot;C:/Users/alexb/Google Drive/CVEN 6833 ADAT/zz Homeworks/HW3/amo.txt&quot;</span>)
pdo=<span class="kw">read.table</span>(<span class="st">&quot;C:/Users/alexb/Google Drive/CVEN 6833 ADAT/zz Homeworks/HW3/pdo.txt&quot;</span>)

X =<span class="st"> </span><span class="kw">data.frame</span>(decoding[<span class="op">-</span>N]<span class="op">-</span><span class="dv">1</span>,enso[<span class="op">-</span>N,],amo[<span class="op">-</span>N,],pdo[<span class="op">-</span>N,])
<span class="kw">colnames</span>(X) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;ts1&quot;</span>,<span class="st">&quot;enso&quot;</span>,<span class="st">&quot;amo&quot;</span>,<span class="st">&quot;pdo&quot;</span>)
Y =<span class="st"> </span>decoding[<span class="op">-</span><span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>

links =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;logit&quot;</span>, <span class="st">&quot;probit&quot;</span>, <span class="st">&quot;cauchit&quot;</span>,<span class="st">&quot;log&quot;</span>,<span class="st">&quot;cloglog&quot;</span>) <span class="co"># potential links</span>

comb=<span class="kw">leaps</span>(X,Y, <span class="dt">nbest=</span><span class="dv">40</span>,<span class="dt">method=</span><span class="st">&quot;adjr2&quot;</span>)<span class="op">$</span>which <span class="co"># all combinations of cov.</span>
aic &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="fl">1e6</span>,<span class="dt">ncol=</span><span class="kw">length</span>(links),<span class="dt">nrow =</span> <span class="kw">length</span>(comb[,<span class="dv">1</span>]))
<span class="kw">colnames</span>(aic) =<span class="st"> </span>links[<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(links)]

<span class="cf">for</span>(k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(comb[,<span class="dv">1</span>])){ <span class="co"># try every link f. with every comb.</span>
  xx =<span class="st"> </span>X[,comb[k,]] <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.data.frame</span>(.)
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(links)){
    zz=<span class="kw">try</span>(<span class="kw">glm</span>(Y <span class="op">~</span><span class="st"> </span>., <span class="dt">data=</span>xx, <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="dt">link=</span>links[i]), <span class="dt">maxit=</span><span class="dv">500</span>),<span class="dt">silent=</span><span class="ot">TRUE</span>)
    <span class="cf">if</span>(<span class="kw">class</span>(zz)[<span class="dv">1</span>]<span class="op">!=</span><span class="st">&quot;try-error&quot;</span>)aic[k,i]=zz<span class="op">$</span>aic[<span class="dv">1</span>]
  }
}
<span class="kw">head</span>(aic)</code></pre></div>
<pre><code>##         logit   probit  cauchit          log  cloglog
## [1,] 125.3869 125.3869 125.3869     125.3869 125.3869
## [2,] 146.9211 146.8480 147.3203     147.6516 147.2601
## [3,] 148.3173 148.4183 147.6240     148.3154 148.2197
## [4,] 151.5616 151.5576 151.5843     151.5754 151.5692
## [5,] 124.8050 124.6801 125.4507 1000000.0000 125.1181
## [6,] 125.5837 125.6196 125.6204 1000000.0000 125.7381</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">index =<span class="st"> </span><span class="kw">which</span>(aic <span class="op">==</span><span class="st"> </span><span class="kw">min</span>(aic), <span class="dt">arr.ind =</span> <span class="ot">TRUE</span>) <span class="co"># select min. AIC</span>
<span class="kw">print</span>(
<span class="kw">sprintf</span>(<span class="st">&quot;Choosing the GLM which minimizes AIC for binomial family: %s link function and %s covariates&quot;</span>,links[index[,<span class="st">&quot;col&quot;</span>]],
        <span class="kw">paste</span>(<span class="kw">colnames</span>(X)[comb[index[,<span class="st">&quot;row&quot;</span>],]],<span class="dt">collapse =</span> <span class="st">&#39;, &#39;</span>)))</code></pre></div>
<pre><code>## [1] &quot;Choosing the GLM which minimizes AIC for binomial family: probit link function and ts1, amo covariates&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">state.glm =<span class="st"> </span><span class="kw">glm</span>(Y <span class="op">~</span><span class="st"> </span>., <span class="dt">data=</span>X[,comb[index[,<span class="st">&quot;row&quot;</span>],]], <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="dt">link=</span>links[index[,<span class="st">&quot;col&quot;</span>]]))
<span class="kw">summary</span>(state.glm) <span class="co"># Model selected</span></code></pre></div>
<pre><code>## 
## Call:
## glm(formula = Y ~ ., family = binomial(link = links[index[, &quot;col&quot;]]), 
##     data = X[, comb[index[, &quot;row&quot;], ]])
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -1.7872  -0.7333  -0.5345   0.8427   1.9937  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)  -0.8180     0.1756  -4.658 3.19e-06 ***
## ts1           1.2820     0.2683   4.779 1.76e-06 ***
## amo           0.9847     0.5931   1.660   0.0969 .  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 148.06  on 109  degrees of freedom
## Residual deviance: 118.68  on 107  degrees of freedom
## AIC: 124.68
## 
## Number of Fisher Scoring iterations: 4</code></pre>
<p>ENSO and PDO covariates resulted to be insignificant for the logistic regression, even if several laggings from the original data have been tried.</p>
</div>
<div id="use-the-state-glm-to-simulate-flows-from-the-component-distribution" class="section level2">
<h2><span class="header-section-number">4.5</span> Use the state GLM to simulate flows from the component distribution</h2>
<p>With the fitted values from the logistic regression, we calculate first the probabilities (p1, p2) of each state.</p>
<p>These are used to generate a random initial state and simulate the rest of the state sequence.</p>
<p>Depending on the simulated sequence, a random gamma value is taken from either state 1 or state 2, creating a new streamflow time series, with the same length as the original data.</p>
<p>The simulation is repeated 250 to generate statistics and ensemble PDF.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">X.new =<span class="st"> </span>X[,comb[index[,<span class="st">&quot;row&quot;</span>],]]
p1 =<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">round</span>(state.glm<span class="op">$</span>fitted.values))<span class="op">/</span><span class="kw">length</span>(state.glm<span class="op">$</span>fitted.values)

state =<span class="st"> </span><span class="dv">1</span><span class="op">:</span>N <span class="co"># init. state</span>
state.p1 =<span class="st"> </span><span class="dv">1</span><span class="op">:</span>nsim <span class="co"># store p1 for debugging</span>

may.sim.glm =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow=</span>nsim,<span class="dt">ncol=</span>N)
sim.pdf.glm =<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow=</span>nsim,<span class="dt">ncol=</span><span class="dv">100</span>) <span class="co"># Array to store May simulated PDF</span>

may.stat.glm=<span class="kw">matrix</span>(<span class="ot">NA</span>,<span class="dt">ncol =</span> <span class="dv">6</span>,<span class="dt">nrow =</span> nsim) <span class="co"># statistics</span>
<span class="kw">colnames</span>(may.stat.glm) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;mean&quot;</span>,<span class="st">&quot;stdev&quot;</span>,<span class="st">&quot;min&quot;</span>,<span class="st">&quot;max&quot;</span>,<span class="st">&quot;skew&quot;</span>,<span class="st">&quot;cor&quot;</span>)

<span class="co"># simulation</span>
<span class="cf">for</span>(isim <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nsim){
  <span class="co"># for(j in 2:N)state[j]=round(predict(state.glm,newdata = data.frame(ts1=state[j-1],amo =   amo[j-1,1])))</span>
  <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N){
    <span class="cf">if</span>(j<span class="op">==</span><span class="dv">1</span>){
      state[<span class="dv">1</span>]=<span class="kw">ifelse</span>(<span class="kw">runif</span>(<span class="dv">1</span>)<span class="op">&lt;</span>p1,<span class="dv">1</span>,<span class="dv">2</span>)
    }<span class="cf">else</span>{
      state[j]=<span class="kw">ifelse</span>(state.glm<span class="op">$</span>fitted.values[j<span class="op">-</span><span class="dv">1</span>]<span class="op">&lt;</span><span class="kw">runif</span>(<span class="dv">1</span>),<span class="dv">1</span>,<span class="dv">2</span>)
    }
    <span class="cf">if</span>(state[j]<span class="op">==</span><span class="dv">1</span>){
      may.sim.glm[isim,j]=<span class="kw">rgamma</span>(<span class="dv">1</span>,<span class="dt">shape =</span> hmm<span class="op">$</span>pm<span class="op">$</span>shape[<span class="dv">1</span>],hmm<span class="op">$</span>pm<span class="op">$</span>rate[<span class="dv">1</span>])
    }<span class="cf">else</span>{
      may.sim.glm[isim,j]=<span class="kw">rgamma</span>(<span class="dv">1</span>,<span class="dt">shape =</span> hmm<span class="op">$</span>pm<span class="op">$</span>shape[<span class="dv">2</span>],hmm<span class="op">$</span>pm<span class="op">$</span>rate[<span class="dv">2</span>])
    }
  }
  state.p1[isim] =<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">sum</span>((state<span class="op">-</span><span class="dv">1</span>))<span class="op">/</span><span class="kw">length</span>(state)
  sim.pdf.glm[isim,]=<span class="kw">sm.density</span>(may.sim.glm[isim,],
                                <span class="dt">eval.points=</span>xeval,<span class="dt">display=</span><span class="st">&quot;none&quot;</span>)<span class="op">$</span>estimate
  <span class="co"># fill statistics</span>
  may.stat.glm[isim,<span class="st">&quot;mean&quot;</span>]=<span class="kw">mean</span>(may.sim.glm[isim,])
  may.stat.glm[isim,<span class="st">&quot;max&quot;</span>]=<span class="kw">max</span>(may.sim.glm[isim,])
  may.stat.glm[isim,<span class="st">&quot;min&quot;</span>]=<span class="kw">min</span>(may.sim.glm[isim,])
  may.stat.glm[isim,<span class="st">&quot;stdev&quot;</span>]=<span class="kw">sd</span>(may.sim.glm[isim,])
  may.stat.glm[isim,<span class="st">&quot;skew&quot;</span>]=<span class="kw">skewness</span>(may.sim.glm[isim,])
  may.stat.glm[isim,<span class="st">&quot;cor&quot;</span>]=<span class="kw">cor</span>(may.sim.glm[isim,<span class="op">-</span>N],may.sim.glm[isim,<span class="dv">2</span><span class="op">:</span>N])
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># bind the stats of the historic data at the top..</span>
may.stat.glm=<span class="kw">rbind</span>(obs,may.stat.glm)
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">3</span>))
<span class="kw">plot.bp</span>(may.stat.glm[,<span class="st">&quot;mean&quot;</span>],<span class="st">&quot;Mean&quot;</span>)
<span class="kw">plot.bp</span>(may.stat.glm[,<span class="st">&quot;stdev&quot;</span>],<span class="st">&quot;Standard Deviation&quot;</span>)
<span class="kw">plot.bp</span>(may.stat.glm[,<span class="st">&quot;min&quot;</span>],<span class="st">&quot;Min&quot;</span>)
<span class="kw">plot.bp</span>(may.stat.glm[,<span class="st">&quot;max&quot;</span>],<span class="st">&quot;Max&quot;</span>)
<span class="kw">plot.bp</span>(may.stat.glm[,<span class="st">&quot;skew&quot;</span>],<span class="st">&quot;Skews&quot;</span>)
<span class="kw">plot.bp</span>(may.stat.glm[,<span class="st">&quot;cor&quot;</span>],<span class="st">&quot;Lag-1 correlation&quot;</span>)</code></pre></div>
<p><img src="CVEN_6833_-_HW3_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot.pdf</span>(xeval,xdensityorig,sim.pdf.glm)</code></pre></div>
<p><img src="CVEN_6833_-_HW3_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<p>Functions from lib.R:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># source functions</span>
<span class="co"># takend from &quot;http://civil.colorado.edu/~balajir/CVEN6833/R-sessions/session3/files-4HW3/lib.R&quot;</span>

Pi_init &lt;-<span class="st"> </span><span class="cf">function</span>(n,<span class="dt">type=</span><span class="st">&#39;uniform&#39;</span>){
    <span class="kw">matrix</span>(<span class="kw">rep</span>(<span class="dv">1</span><span class="op">/</span>n,n<span class="op">^</span><span class="dv">2</span>),n)}

delta_init &lt;-<span class="st"> </span><span class="cf">function</span>(n, <span class="dt">type=</span><span class="st">&#39;uniform&#39;</span>){
    d &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n)<span class="op">^</span><span class="dv">2</span>
    d<span class="op">/</span><span class="kw">sum</span>(d)}

ntile.ts &lt;-<span class="st"> </span>
<span class="cf">function</span>(x, n, <span class="dt">limit.type =</span> <span class="st">&#39;prob&#39;</span>, <span class="dt">tie =</span> <span class="dv">1</span>, <span class="dt">altobs =</span> <span class="ot">NULL</span> ){
    <span class="co"># returns an integer vector corresponding to n states broken by equal </span>
    <span class="co"># probability or equal distance</span>
    <span class="co">#</span>
    limit &lt;-<span class="st"> </span>
<span class="st">    </span><span class="cf">if</span>(limit.type <span class="op">==</span><span class="st"> &#39;prob&#39;</span>) 
      <span class="kw">quantile</span>(x,<span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span><span class="op">/</span>n))
    <span class="cf">else</span> <span class="cf">if</span>(limit.type <span class="op">==</span><span class="st"> &#39;equal&#39;</span>)
      <span class="kw">seq</span>(<span class="kw">min</span>(x),<span class="kw">max</span>(x),<span class="dt">by=</span><span class="kw">diff</span>(<span class="kw">range</span>(x))<span class="op">/</span>n)

    <span class="cf">if</span>(<span class="op">!</span><span class="kw">is.null</span>(altobs)) limit &lt;-<span class="st"> </span><span class="kw">quantile</span>(altobs,<span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">1</span><span class="op">/</span>n))
    
    b &lt;-<span class="st"> </span><span class="kw">integer</span>(<span class="kw">length</span>(x))
    
    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>(n<span class="op">+</span><span class="dv">1</span>)){
        filter &lt;-<span class="st"> </span>
<span class="st">        </span><span class="cf">if</span>(tie <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) 
            x <span class="op">&gt;=</span><span class="st"> </span>limit[i] <span class="op">&amp;</span><span class="st"> </span>x <span class="op">&lt;=</span><span class="st"> </span>limit[i<span class="op">+</span><span class="dv">1</span>]
        <span class="cf">else</span> 
            x <span class="op">&gt;</span><span class="st"> </span>limit[i] <span class="op">&amp;</span><span class="st"> </span>x <span class="op">&lt;=</span><span class="st"> </span>limit[i<span class="op">+</span><span class="dv">1</span>]
    
        <span class="co">#only need to set the 1&#39;s because b is already 0&#39;s</span>
        b[filter] &lt;-<span class="st"> </span><span class="kw">as.integer</span>(i<span class="op">-</span><span class="dv">1</span>)
    }
    
    <span class="cf">if</span>(<span class="kw">class</span>(x) <span class="op">==</span><span class="st"> &#39;ts&#39;</span>) 
        <span class="kw">return</span>(<span class="kw">ts</span>(b,<span class="dt">start=</span><span class="kw">start</span>(x),<span class="dt">end=</span><span class="kw">end</span>(x))) 
    <span class="cf">else</span> 
        <span class="kw">return</span>(b)
}

get.named.parlist &lt;-<span class="st"> </span><span class="cf">function</span>(x,m,dist,ic,...){
    <span class="kw">require</span>(MASS)
    fit &lt;-<span class="st"> </span><span class="kw">fitdistr</span>(x,dist,...)
    np &lt;-<span class="st"> </span><span class="kw">length</span>(fit<span class="op">$</span>estimate)
    pars &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&#39;list&#39;</span>,np)
    <span class="kw">names</span>(pars) &lt;-<span class="st"> </span><span class="kw">names</span>(fit<span class="op">$</span>estimate)

    init &lt;-<span class="st"> </span><span class="kw">lapply</span>(fit<span class="op">$</span>estimate,max)
    <span class="kw">names</span>(init) &lt;-<span class="st"> </span><span class="kw">names</span>(fit<span class="op">$</span>estimate)

    <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
        <span class="co">#print(j)</span>
        <span class="co">#browser()</span>

        <span class="co">#browser()</span>
        this.fit &lt;-<span class="st"> </span><span class="kw">fitdistr</span>(x[<span class="kw">ntile.ts</span>(x,m) <span class="op">==</span><span class="st"> </span>(j<span class="op">-</span><span class="dv">1</span>)],dist,init,...)
        <span class="co">#for(k in 1:np)</span>
        <span class="co">#    pars[[k]][j] &lt;- this.fit$estimate[k]</span>
        <span class="cf">for</span>(k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>np)
            pars[[k]][j] &lt;-<span class="st"> </span>fit<span class="op">$</span>estimate[k]
        <span class="cf">if</span>(dist <span class="op">==</span><span class="st"> &#39;normal&#39;</span>){
            <span class="cf">if</span>(ic <span class="op">==</span><span class="st"> &#39;same.both&#39;</span>){
                pars[[k]][j] &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
                pars[[k]][j] &lt;-<span class="st"> </span><span class="kw">sd</span>(x)
            } <span class="cf">else</span> <span class="cf">if</span>( ic <span class="op">==</span><span class="st"> &#39;same.sd&#39;</span>){
                pars[[k]][j] &lt;-<span class="st"> </span><span class="kw">mean</span>(x[<span class="kw">ntile.ts</span>(x,m) <span class="op">==</span><span class="st"> </span>(j<span class="op">-</span><span class="dv">1</span>)])
                pars[[k]][j] &lt;-<span class="st"> </span><span class="kw">sd</span>(x)
            }<span class="cf">else</span>{
                pars[[k]][j] &lt;-<span class="st"> </span><span class="kw">mean</span>(x[<span class="kw">ntile.ts</span>(x,m) <span class="op">==</span><span class="st"> </span>(j<span class="op">-</span><span class="dv">1</span>)])
                pars[[k]][j] &lt;-<span class="st"> </span><span class="kw">sd</span>(x[<span class="kw">ntile.ts</span>(x,m) <span class="op">==</span><span class="st"> </span>(j<span class="op">-</span><span class="dv">1</span>)])
            }
        }
    }
    pars
}

AIC.dthmm &lt;-<span class="st"> </span><span class="cf">function</span>(x){
  ## Return the Akaieke Information criterion value for a fitted discrete 
  ## time hidden markov model from the HiddenMarkov package
  
    <span class="co"># Model order</span>
  m &lt;-<span class="st"> </span><span class="kw">length</span>(x<span class="op">$</span>delta)
    <span class="co"># Log Liklihood value</span>
  LL &lt;-<span class="st"> </span>x<span class="op">$</span>LL
    <span class="co"># number of parameters</span>
  p &lt;-<span class="st"> </span>m<span class="op">+</span>m<span class="op">^</span><span class="dv">2</span>
    <span class="co"># AIC</span>
  <span class="op">-</span><span class="dv">2</span><span class="op">*</span>LL <span class="op">+</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span>p
}

ggplot_stationary_hmm &lt;-<span class="st"> </span><span class="cf">function</span>(x,<span class="dt">binwidth=</span><span class="ot">NULL</span>,<span class="dt">res=</span><span class="dv">1000</span>,<span class="dt">cols=</span><span class="ot">NULL</span>,...){
    
    m &lt;-<span class="st"> </span><span class="kw">length</span>(x<span class="op">$</span>delta)
    dens &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow=</span>m<span class="op">+</span><span class="dv">1</span>,<span class="dt">ncol=</span>res)
    r &lt;-<span class="st"> </span><span class="kw">extendrange</span>(x<span class="op">$</span>x,<span class="dt">f=</span>.<span class="dv">05</span>)
    xrange &lt;-<span class="st"> </span><span class="kw">seq</span>(r[<span class="dv">1</span>],r[<span class="dv">2</span>],<span class="dt">len=</span>res)
    delta &lt;-<span class="st"> </span><span class="kw">statdist</span>(x<span class="op">$</span>Pi)
    <span class="cf">if</span>(<span class="kw">is.null</span>(binwidth)) binwidth &lt;-<span class="st"> </span><span class="kw">diff</span>(<span class="kw">range</span>(x<span class="op">$</span>x))<span class="op">/</span><span class="dv">8</span>
    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
        
        <span class="cf">if</span>(x<span class="op">$</span>distn <span class="op">==</span><span class="st"> &#39;gamma&#39;</span>){
            dens[i,] &lt;-<span class="st"> </span>delta[i]<span class="op">*</span><span class="kw">dgamma</span>(xrange,<span class="dt">shape=</span>x<span class="op">$</span>pm<span class="op">$</span>shape[i],<span class="dt">rate=</span>x<span class="op">$</span>pm<span class="op">$</span>rate[i])
        }<span class="cf">else</span> <span class="cf">if</span>(x<span class="op">$</span>distn <span class="op">==</span><span class="st"> &#39;norm&#39;</span>){
            dens[i,] &lt;-<span class="st"> </span>delta[i]<span class="op">*</span><span class="kw">dnorm</span>(xrange,<span class="dt">mean=</span>x<span class="op">$</span>pm<span class="op">$</span>mean[i],<span class="dt">sd=</span>x<span class="op">$</span>pm<span class="op">$</span>sd[i])
        }<span class="cf">else</span>{
            <span class="kw">stop</span>(<span class="st">&#39;Distribution not supported&#39;</span>)
        }
            
        dens[m<span class="op">+</span><span class="dv">1</span>,] &lt;-<span class="st"> </span>dens[m<span class="op">+</span><span class="dv">1</span>,] <span class="op">+</span><span class="st"> </span>dens[i,]
    }

    p &lt;-<span class="st"> </span><span class="kw">ggplot</span>()<span class="op">+</span>
<span class="st">        </span><span class="kw">geom_histogram</span>(<span class="dt">data=</span><span class="kw">data.frame</span>(<span class="dt">x=</span><span class="kw">as.vector</span>(x<span class="op">$</span>x)),<span class="kw">aes</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>..density..),
            <span class="dt">binwidth=</span>binwidth,<span class="dt">fill=</span><span class="st">&#39;white&#39;</span>,<span class="dt">color=</span><span class="st">&#39;black&#39;</span>)<span class="op">+</span>
<span class="st">        </span><span class="kw">theme_bw</span>()

    dt &lt;-<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">x=</span><span class="kw">numeric</span>(<span class="dv">0</span>),<span class="dt">y=</span><span class="kw">numeric</span>(<span class="dv">0</span>), <span class="dt">state=</span><span class="kw">integer</span>(<span class="dv">0</span>))
    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m)
        dt &lt;-<span class="st"> </span><span class="kw">rbind</span>(dt, <span class="kw">data.table</span>(<span class="dt">x=</span>xrange,<span class="dt">y=</span>dens[i,], <span class="dt">state=</span>i))
    dt<span class="op">$</span>state &lt;-<span class="st"> </span><span class="kw">factor</span>(dt<span class="op">$</span>state)
    
    p &lt;-<span class="st"> </span>p <span class="op">+</span><span class="st"> </span><span class="kw">geom_line</span>(<span class="dt">data=</span>dt,<span class="kw">aes</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y,<span class="dt">color=</span>state)) <span class="op">+</span><span class="st"> </span>
<span class="st">        </span><span class="kw">geom_line</span>(<span class="dt">data=</span><span class="kw">data.frame</span>(<span class="dt">x=</span>xrange,<span class="dt">y=</span>dens[m<span class="op">+</span><span class="dv">1</span>,]),<span class="kw">aes</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y),<span class="dt">color=</span><span class="st">&#39;black&#39;</span>,<span class="dt">size=</span><span class="dv">1</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">        </span><span class="kw">scale_color_tableau</span>() <span class="op">+</span>
<span class="st">        </span><span class="kw">scale_x_continuous</span>(<span class="dt">limits=</span>r)
    p
    
}

statdist &lt;-<span class="st"> </span><span class="cf">function</span>(tpm){
    
    m &lt;-<span class="st"> </span><span class="kw">nrow</span>(tpm)
    ones &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">rep</span>(<span class="dv">1</span>,m))
    I &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="kw">rep</span>(<span class="dv">1</span>,m))
    U &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rep</span>(<span class="dv">1</span>,m<span class="op">^</span><span class="dv">2</span>),m)
    <span class="kw">as.vector</span>(ones <span class="op">%*%</span><span class="st"> </span><span class="kw">solve</span>(I <span class="op">-</span><span class="st"> </span>tpm <span class="op">+</span><span class="st"> </span>U))
    
}</code></pre></div>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="multivariate-simulation-copulas.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page"><i class="fa fa-angle-left"></i></a>

    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["CVEN 6833 - HW3.pdf", "CVEN 6833 - HW3.epub", "CVEN 6833 - HW3.mobi"],
"toc": {
"collapse": "subsection",
"scroll_highlight": true
}
});
});
</script>

</body>

</html>
